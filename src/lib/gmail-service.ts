/**
 * Gmail Communication Management Service
 * Integrates with Gmail API for construction project communication
 */

import { PrismaClient } from '@prisma/client'

// Gmail API types (would be imported from actual Gmail API library)
interface GmailMessage {
  id: string
  threadId: string
  labelIds: string[]
  snippet: string
  historyId: string
  internalDate: string
  payload: {
    partId: string
    mimeType: string
    filename: string
    headers: Array<{
      name: string
      value: string
    }>
    body: {
      attachmentId?: string
      size: number
      data?: string
    }
    parts?: GmailMessage['payload'][]
  }
  sizeEstimate: number
  raw?: string
}

interface GmailThread {
  id: string
  historyId: string
  messages: GmailMessage[]
}

interface GmailAttachment {
  attachmentId: string
  filename: string
  mimeType: string
  size: number
  data?: string
}

interface RFPTemplate {
  projectId: string
  trade: string
  projectDetails: {
    name: string
    address: string
    scope: string
    timeline: string
    budget?: string
  }
  requirements: string[]
  specifications: Record<string, any>
  submissionDeadline: Date
}

interface VendorCommunication {
  vendorId: string
  vendorName: string
  vendorEmail: string
  messagesSent: number
  responsesReceived: number
  lastContact: Date
  responseTime: number // hours
  status: 'PENDING' | 'RESPONDED' | 'SELECTED' | 'DECLINED'
}

interface EmailTemplate {
  name: string
  subject: string
  body: string
  variables: string[]
  category: 'RFP' | 'FOLLOW_UP' | 'SELECTION' | 'REJECTION' | 'GENERAL'
}

export class GmailConstructionService {
  private prisma: PrismaClient
  private projectEmail: string

  constructor(projectEmail: string) {
    this.prisma = new PrismaClient()
    this.projectEmail = projectEmail
  }

  /**
   * Generate and send RFP emails to vendors
   */
  async generateAndSendRFP(
    template: RFPTemplate,
    vendorEmails: string[]
  ): Promise<{
    sent: number
    failed: Array<{ email: string; error: string }>
    messageIds: string[]
  }> {
    try {
      const rfpContent = await this.generateRFPContent(template)
      const results = {
        sent: 0,
        failed: [] as Array<{ email: string; error: string }>,
        messageIds: [] as string[]
      }

      for (const vendorEmail of vendorEmails) {
        try {
          const personalizedContent = await this.personalizeRFP(rfpContent, vendorEmail)
          const messageId = await this.sendEmail({
            to: vendorEmail,
            subject: personalizedContent.subject,
            body: personalizedContent.body,
            attachments: personalizedContent.attachments
          })

          // Track in database
          await this.trackCommunication({
            projectId: template.projectId,
            type: 'RFP',
            subject: personalizedContent.subject,
            content: personalizedContent.body,
            direction: 'OUTBOUND',
            toEmails: [vendorEmail],
            gmailId: messageId,
            status: 'READ', // Outbound emails are marked as read
            isAutoGenerated: true,
            responseRequired: true,
            followUpDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
          })

          results.sent++
          results.messageIds.push(messageId)
        } catch (error) {
          results.failed.push({
            email: vendorEmail,
            error: error.message
          })
        }
      }

      return results
    } catch (error) {
      console.error('RFP generation failed:', error)
      throw new Error(`Failed to generate and send RFP: ${error.message}`)
    }
  }

  /**
   * Parse incoming vendor responses
   */
  async parseVendorResponse(message: GmailMessage): Promise<{
    vendorInfo: any
    quote: any
    timeline: any
    materials: any[]
    nextSteps: string[]
    confidence: number
  }> {
    try {
      const emailContent = this.extractEmailContent(message)
      const extractedData = await this.extractStructuredData(emailContent)

      // Store the communication
      await this.trackCommunication({
        projectId: await this.getProjectIdFromEmail(message),
        type: 'QUOTE_RESPONSE',
        subject: this.getHeader(message, 'Subject'),
        content: emailContent,
        direction: 'INBOUND',
        fromEmail: this.getHeader(message, 'From'),
        gmailId: message.id,
        threadId: message.threadId,
        status: 'UNREAD',
        extractedData,
        responseRequired: false
      })

      return extractedData
    } catch (error) {
      console.error('Response parsing failed:', error)
      throw new Error(`Failed to parse vendor response: ${error.message}`)
    }
  }

  /**
   * Automated follow-up management
   */
  async processFollowUps(): Promise<{
    sent: number
    overdue: number
    errors: string[]
  }> {
    try {
      // Find communications requiring follow-up
      const pendingFollowUps = await this.prisma.communication.findMany({
        where: {
          responseRequired: true,
          status: 'UNREAD',
          followUpDate: {
            lte: new Date()
          },
          direction: 'OUTBOUND'
        },
        include: {
          project: true
        }
      })

      const results = {
        sent: 0,
        overdue: 0,
        errors: [] as string[]
      }

      for (const communication of pendingFollowUps) {
        try {
          const daysSinceOriginal = Math.floor(
            (Date.now() - communication.createdAt.getTime()) / (1000 * 60 * 60 * 24)
          )

          if (daysSinceOriginal > 14) {
            results.overdue++
            continue
          }

          const followUpTemplate = this.getFollowUpTemplate(
            communication.type as any,
            daysSinceOriginal
          )

          const messageId = await this.sendEmail({
            to: communication.toEmails[0],
            subject: `Follow-up: ${communication.subject}`,
            body: this.generateFollowUpContent(followUpTemplate, communication),
            replyTo: communication.gmailId
          })

          // Update follow-up date
          await this.prisma.communication.update({
            where: { id: communication.id },
            data: {
              followUpDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
            }
          })

          results.sent++
        } catch (error) {
          results.errors.push(`Follow-up failed for ${communication.id}: ${error.message}`)
        }
      }

      return results
    } catch (error) {
      console.error('Follow-up processing failed:', error)
      throw new Error(`Failed to process follow-ups: ${error.message}`)
    }
  }

  /**
   * Extract and categorize email attachments
   */
  async processEmailAttachments(
    message: GmailMessage,
    projectId: string
  ): Promise<{
    processed: number
    documents: Array<{
      filename: string
      type: string
      path: string
      category: string
    }>
  }> {
    try {
      const attachments = await this.extractAttachments(message)
      const processedDocs = []

      for (const attachment of attachments) {
        const category = this.categorizeDocument(attachment.filename, attachment.mimeType)
        const filePath = await this.saveAttachment(attachment, projectId)

        // Create document record
        const document = await this.prisma.document.create({
          data: {
            projectId,
            name: attachment.filename,
            type: this.mapToDocumentType(category),
            category,
            fileName: attachment.filename,
            filePath,
            fileSize: attachment.size,
            mimeType: attachment.mimeType,
            uploadedById: 'system' // System user for email attachments
          }
        })

        processedDocs.push({
          filename: attachment.filename,
          type: attachment.mimeType,
          path: filePath,
          category
        })
      }

      return {
        processed: processedDocs.length,
        documents: processedDocs
      }
    } catch (error) {
      console.error('Attachment processing failed:', error)
      throw new Error(`Failed to process attachments: ${error.message}`)
    }
  }

  /**
   * Generate vendor communication analytics
   */
  async generateCommunicationAnalytics(projectId: string): Promise<{
    overview: {
      totalCommunications: number
      vendorsContacted: number
      responsesReceived: number
      responseRate: number
      averageResponseTime: number
    }
    vendorStats: VendorCommunication[]
    timeline: Array<{
      date: string
      sent: number
      received: number
    }>
  }> {
    try {
      const communications = await this.prisma.communication.findMany({
        where: { projectId },
        orderBy: { createdAt: 'asc' }
      })

      const overview = this.calculateOverviewStats(communications)
      const vendorStats = this.calculateVendorStats(communications)
      const timeline = this.generateTimelineData(communications)

      return {
        overview,
        vendorStats,
        timeline
      }
    } catch (error) {
      console.error('Analytics generation failed:', error)
      throw new Error(`Failed to generate analytics: ${error.message}`)
    }
  }

  // Private helper methods
  private async generateRFPContent(template: RFPTemplate): Promise<{
    subject: string
    body: string
    attachments: string[]
  }> {
    const subject = `RFP: ${template.trade} Services - ${template.projectDetails.name}`
    
    const body = `
Dear Contractor,

We are seeking qualified ${template.trade} contractors for our upcoming project:

PROJECT DETAILS:
- Project: ${template.projectDetails.name}
- Location: ${template.projectDetails.address}
- Scope: ${template.projectDetails.scope}
- Timeline: ${template.projectDetails.timeline}
${template.projectDetails.budget ? `- Budget Range: ${template.projectDetails.budget}` : ''}

REQUIREMENTS:
${template.requirements.map(req => `• ${req}`).join('\n')}

SPECIFICATIONS:
${Object.entries(template.specifications).map(([key, value]) => `• ${key}: ${value}`).join('\n')}

Please provide your quote including:
1. Detailed scope of work
2. Material and labor breakdown
3. Timeline for completion
4. License and insurance information
5. References from recent projects

Submission Deadline: ${template.submissionDeadline.toLocaleDateString()}

We look forward to your response.

Best regards,
Home Builder Pro Project Team
    `.trim()

    return {
      subject,
      body,
      attachments: [] // Could include project plans, specifications, etc.
    }
  }

  private async personalizeRFP(
    content: { subject: string; body: string; attachments: string[] },
    vendorEmail: string
  ): Promise<{ subject: string; body: string; attachments: string[] }> {
    // Look up vendor information from database
    const vendor = await this.prisma.supplier.findFirst({
      where: { email: vendorEmail }
    })

    if (vendor) {
      // Personalize with vendor name
      const personalizedBody = `Dear ${vendor.name} Team,\n\n${content.body}`
      return {
        ...content,
        body: personalizedBody
      }
    }

    return content
  }

  private async sendEmail(params: {
    to: string
    subject: string
    body: string
    attachments?: string[]
    replyTo?: string
  }): Promise<string> {
    // Mock implementation - would integrate with actual Gmail API
    const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    
    // Simulate email sending delay
    await new Promise(resolve => setTimeout(resolve, 100))
    
    console.log(`[MOCK] Sending email to ${params.to}: ${params.subject}`)
    
    return messageId
  }

  private async trackCommunication(data: {
    projectId: string
    type: string
    subject?: string
    content: string
    direction: string
    fromEmail?: string
    toEmails?: string[]
    gmailId?: string
    threadId?: string
    status: string
    isAutoGenerated?: boolean
    responseRequired?: boolean
    followUpDate?: Date
    extractedData?: any
  }): Promise<void> {
    await this.prisma.communication.create({
      data: {
        projectId: data.projectId,
        type: data.type as any,
        subject: data.subject,
        content: data.content,
        direction: data.direction,
        fromEmail: data.fromEmail,
        toEmails: data.toEmails || [],
        gmailId: data.gmailId,
        threadId: data.threadId,
        status: data.status as any,
        isAutoGenerated: data.isAutoGenerated || false,
        responseRequired: data.responseRequired || false,
        followUpDate: data.followUpDate,
        extractedData: data.extractedData
      }
    })
  }

  private extractEmailContent(message: GmailMessage): string {
    // Extract text content from Gmail message
    if (message.payload.body.data) {
      return Buffer.from(message.payload.body.data, 'base64').toString('utf-8')
    }
    
    // Handle multipart messages
    if (message.payload.parts) {
      for (const part of message.payload.parts) {
        if (part.mimeType === 'text/plain' && part.body.data) {
          return Buffer.from(part.body.data, 'base64').toString('utf-8')
        }
      }
    }
    
    return message.snippet
  }

  private getHeader(message: GmailMessage, headerName: string): string {
    const header = message.payload.headers.find(h => h.name === headerName)
    return header?.value || ''
  }

  private async extractStructuredData(emailContent: string): Promise<any> {
    // Mock AI extraction - would use actual AI service
    return {
      vendorInfo: {
        name: 'Extracted Vendor Name',
        contact: 'Extracted Contact'
      },
      quote: {
        total: 0,
        breakdown: []
      },
      timeline: {
        startDate: null,
        duration: null
      },
      materials: [],
      nextSteps: ['Review quote', 'Schedule meeting'],
      confidence: 0.8
    }
  }

  private async getProjectIdFromEmail(message: GmailMessage): Promise<string> {
    // Extract project ID from email thread or subject
    // This would be implemented based on email tagging strategy
    return 'default_project_id'
  }

  private getFollowUpTemplate(type: string, daysSince: number): EmailTemplate {
    if (daysSince <= 7) {
      return {
        name: 'First Follow-up',
        subject: 'Follow-up: Quote Request',
        body: 'We wanted to follow up on our recent quote request. Please let us know if you need any additional information.',
        variables: ['project_name', 'original_date'],
        category: 'FOLLOW_UP'
      }
    } else {
      return {
        name: 'Final Follow-up',
        subject: 'Final Follow-up: Quote Request',
        body: 'This is our final follow-up regarding the quote request. Please respond by end of week if you are interested.',
        variables: ['project_name', 'deadline'],
        category: 'FOLLOW_UP'
      }
    }
  }

  private generateFollowUpContent(template: EmailTemplate, originalCommunication: any): string {
    return template.body
      .replace('{{project_name}}', originalCommunication.project?.name || 'the project')
      .replace('{{original_date}}', originalCommunication.createdAt.toLocaleDateString())
  }

  private async extractAttachments(message: GmailMessage): Promise<GmailAttachment[]> {
    const attachments: GmailAttachment[] = []
    
    const processPayload = (payload: any) => {
      if (payload.filename && payload.body.attachmentId) {
        attachments.push({
          attachmentId: payload.body.attachmentId,
          filename: payload.filename,
          mimeType: payload.mimeType,
          size: payload.body.size
        })
      }
      
      if (payload.parts) {
        payload.parts.forEach(processPayload)
      }
    }
    
    processPayload(message.payload)
    return attachments
  }

  private categorizeDocument(filename: string, mimeType: string): string {
    const ext = filename.split('.').pop()?.toLowerCase()
    
    if (['pdf'].includes(ext || '')) {
      if (filename.toLowerCase().includes('quote') || filename.toLowerCase().includes('estimate')) {
        return 'QUOTE'
      }
      if (filename.toLowerCase().includes('contract')) {
        return 'CONTRACT'
      }
      if (filename.toLowerCase().includes('plan')) {
        return 'PLAN'
      }
    }
    
    if (['jpg', 'jpeg', 'png', 'gif'].includes(ext || '')) {
      return 'PHOTO'
    }
    
    if (['doc', 'docx', 'txt'].includes(ext || '')) {
      return 'DOCUMENT'
    }
    
    return 'OTHER'
  }

  private mapToDocumentType(category: string): 'CONTRACT' | 'PERMIT' | 'INSPECTION' | 'PHOTO' | 'PLAN' | 'SPECIFICATION' | 'INVOICE' | 'RECEIPT' | 'OTHER' {
    const mapping: Record<string, any> = {
      'QUOTE': 'INVOICE',
      'CONTRACT': 'CONTRACT',
      'PLAN': 'PLAN',
      'PHOTO': 'PHOTO',
      'DOCUMENT': 'OTHER'
    }
    
    return mapping[category] || 'OTHER'
  }

  private async saveAttachment(attachment: GmailAttachment, projectId: string): Promise<string> {
    // Mock implementation - would save to actual file storage
    const filename = `${projectId}_${Date.now()}_${attachment.filename}`
    const filePath = `/attachments/${filename}`
    
    console.log(`[MOCK] Saving attachment: ${filename}`)
    
    return filePath
  }

  private calculateOverviewStats(communications: any[]): any {
    const total = communications.length
    const sent = communications.filter(c => c.direction === 'OUTBOUND').length
    const received = communications.filter(c => c.direction === 'INBOUND').length
    const vendors = new Set(communications.map(c => c.fromEmail || c.toEmails[0])).size
    
    return {
      totalCommunications: total,
      vendorsContacted: vendors,
      responsesReceived: received,
      responseRate: sent > 0 ? (received / sent) * 100 : 0,
      averageResponseTime: 24 // Mock value
    }
  }

  private calculateVendorStats(communications: any[]): VendorCommunication[] {
    // Group communications by vendor
    const vendorMap = new Map()
    
    communications.forEach(comm => {
      const email = comm.fromEmail || comm.toEmails[0]
      if (!vendorMap.has(email)) {
        vendorMap.set(email, {
          vendorEmail: email,
          vendorName: 'Unknown Vendor',
          messagesSent: 0,
          responsesReceived: 0,
          lastContact: comm.createdAt,
          responseTime: 0,
          status: 'PENDING'
        })
      }
      
      const vendor = vendorMap.get(email)
      if (comm.direction === 'OUTBOUND') {
        vendor.messagesSent++
      } else {
        vendor.responsesReceived++
      }
      
      if (comm.createdAt > vendor.lastContact) {
        vendor.lastContact = comm.createdAt
      }
    })
    
    return Array.from(vendorMap.values())
  }

  private generateTimelineData(communications: any[]): any[] {
    const timeline = new Map()
    
    communications.forEach(comm => {
      const date = comm.createdAt.toISOString().split('T')[0]
      if (!timeline.has(date)) {
        timeline.set(date, { date, sent: 0, received: 0 })
      }
      
      const day = timeline.get(date)
      if (comm.direction === 'OUTBOUND') {
        day.sent++
      } else {
        day.received++
      }
    })
    
    return Array.from(timeline.values()).sort((a, b) => a.date.localeCompare(b.date))
  }

  async disconnect(): Promise<void> {
    await this.prisma.$disconnect()
  }
}

// Factory function
export function createGmailService(projectEmail: string): GmailConstructionService {
  return new GmailConstructionService(projectEmail)
}