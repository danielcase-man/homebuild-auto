/**
 * Enhanced Gmail API Integration Service
 * Provides comprehensive email management for vendor communications
 */

import { google } from 'googleapis'
import { prisma } from './prisma'

export interface EmailTemplate {
  id: string
  name: string
  subject: string
  body: string
  variables: string[]
  category: 'RFP' | 'QUOTE_REQUEST' | 'FOLLOW_UP' | 'CONTRACT' | 'GENERAL'
}

export interface EmailComposition {
  to: string[]
  cc?: string[]
  bcc?: string[]
  subject: string
  body: string
  attachments?: EmailAttachment[]
  templateId?: string
  templateVariables?: Record<string, any>
  projectId?: string
  vendorId?: string
  priority?: 'HIGH' | 'MEDIUM' | 'LOW'
  trackResponse?: boolean
  scheduleDate?: Date
}

export interface EmailAttachment {
  filename: string
  content: string | Buffer
  contentType: string
  size: number
}

export interface GmailMessage {
  id: string
  threadId: string
  labelIds: string[]
  snippet: string
  payload: any
  internalDate: string
  from: string
  to: string[]
  cc?: string[]
  subject: string
  body: string
  attachments: EmailAttachment[]
  isRead: boolean
  date: Date
}

export interface EmailThread {
  id: string
  messages: GmailMessage[]
  subject: string
  participants: string[]
  lastMessageDate: Date
  isRead: boolean
  labels: string[]
}

export interface RFPEmailData {
  projectId: string
  projectName: string
  trade: string
  description: string
  requirements: string[]
  timeline: {
    startDate: Date
    endDate: Date
    responseDeadline: Date
  }
  budget?: {
    min?: number
    max?: number
    currency: string
  }
  contactInfo: {
    name: string
    email: string
    phone?: string
    company: string
  }
  attachments?: {
    plans?: string[]
    specifications?: string[]
    contracts?: string[]
  }
}

class GmailIntegrationService {
  private gmail: any
  private auth: any
  private isInitialized = false

  constructor() {
    this.initializeGoogleAuth()
  }

  private async initializeGoogleAuth() {
    try {
      this.auth = new google.auth.OAuth2(
        process.env.GOOGLE_CLIENT_ID,
        process.env.GOOGLE_CLIENT_SECRET,
        process.env.GOOGLE_REDIRECT_URI
      )

      // Set credentials if available
      if (process.env.GOOGLE_REFRESH_TOKEN) {
        this.auth.setCredentials({
          refresh_token: process.env.GOOGLE_REFRESH_TOKEN,
          access_token: process.env.GOOGLE_ACCESS_TOKEN
        })
      }

      this.gmail = google.gmail({ version: 'v1', auth: this.auth })
      this.isInitialized = true
    } catch (error) {
      console.error('Failed to initialize Gmail API:', error)
    }
  }

  /**
   * Send email using Gmail API
   */
  async sendEmail(composition: EmailComposition): Promise<{ messageId: string; threadId: string }> {
    if (!this.isInitialized) {
      throw new Error('Gmail service not initialized')
    }

    try {
      let emailBody = composition.body
      
      // Apply template if specified
      if (composition.templateId && composition.templateVariables) {
        const template = await this.getTemplate(composition.templateId)
        emailBody = this.applyTemplate(template, composition.templateVariables)
      }

      // Create email message
      const messageParts = [
        `To: ${composition.to.join(', ')}`,
        composition.cc ? `Cc: ${composition.cc.join(', ')}` : '',
        composition.bcc ? `Bcc: ${composition.bcc.join(', ')}` : '',
        `Subject: ${composition.subject}`,
        'Content-Type: text/html; charset=utf-8',
        'MIME-Version: 1.0',
        '',
        emailBody
      ].filter(Boolean)

      const message = messageParts.join('\n')
      const encodedMessage = Buffer.from(message).toString('base64').replace(/\+/g, '-').replace(/\//g, '_')

      // Send email
      const response = await this.gmail.users.messages.send({
        userId: 'me',
        requestBody: {
          raw: encodedMessage
        }
      })

      // Track the communication in database
      await this.trackCommunication({
        projectId: composition.projectId,
        vendorId: composition.vendorId,
        messageId: response.data.id,
        threadId: response.data.threadId,
        type: 'EMAIL',
        direction: 'OUTBOUND',
        subject: composition.subject,
        content: emailBody,
        toEmails: composition.to,
        ccEmails: composition.cc || [],
        status: 'SENT',
        isAutoGenerated: !!composition.templateId,
        responseRequired: composition.trackResponse || false
      })

      return {
        messageId: response.data.id,
        threadId: response.data.threadId
      }
    } catch (error) {
      console.error('Failed to send email:', error)
      throw error
    }
  }

  /**
   * Generate and send RFP emails to multiple vendors
   */
  async sendRFPEmails(vendorIds: string[], rfpData: RFPEmailData): Promise<{ sent: number; failed: number; results: any[] }> {
    const vendors = await prisma.supplier.findMany({
      where: { id: { in: vendorIds } }
    })

    const template = await this.getTemplate('rfp-standard')
    const results = []
    let sent = 0
    let failed = 0

    for (const vendor of vendors) {
      try {
        if (!vendor.email) {
          results.push({ vendorId: vendor.id, error: 'No email address' })
          failed++
          continue
        }

        const emailComposition: EmailComposition = {
          to: [vendor.email],
          subject: `RFP: ${rfpData.projectName} - ${rfpData.trade} Services`,
          body: this.generateRFPEmail(rfpData, vendor),
          projectId: rfpData.projectId,
          vendorId: vendor.id,
          priority: 'HIGH',
          trackResponse: true
        }

        const result = await this.sendEmail(emailComposition)
        results.push({ vendorId: vendor.id, ...result })
        sent++
      } catch (error) {
        results.push({ vendorId: vendor.id, error: error.message })
        failed++
      }
    }

    return { sent, failed, results }
  }

  /**
   * Fetch and process incoming emails
   */
  async fetchIncomingEmails(query?: string, maxResults = 50): Promise<GmailMessage[]> {
    if (!this.isInitialized) {
      throw new Error('Gmail service not initialized')
    }

    try {
      const searchQuery = query || 'is:unread'
      
      const response = await this.gmail.users.messages.list({
        userId: 'me',
        q: searchQuery,
        maxResults
      })

      const messages = response.data.messages || []
      const detailedMessages = []

      for (const message of messages) {
        const details = await this.gmail.users.messages.get({
          userId: 'me',
          id: message.id
        })

        const parsedMessage = this.parseGmailMessage(details.data)
        detailedMessages.push(parsedMessage)

        // Track incoming communication
        await this.trackIncomingCommunication(parsedMessage)
      }

      return detailedMessages
    } catch (error) {
      console.error('Failed to fetch emails:', error)
      throw error
    }
  }

  /**
   * Get email threads for vendor communications
   */
  async getVendorEmailThreads(vendorEmail: string): Promise<EmailThread[]> {
    try {
      const response = await this.gmail.users.threads.list({
        userId: 'me',
        q: `from:${vendorEmail} OR to:${vendorEmail}`
      })

      const threads = []
      
      for (const thread of response.data.threads || []) {
        const threadDetails = await this.gmail.users.threads.get({
          userId: 'me',
          id: thread.id
        })

        const parsedThread = this.parseEmailThread(threadDetails.data)
        threads.push(parsedThread)
      }

      return threads
    } catch (error) {
      console.error('Failed to fetch vendor email threads:', error)
      throw error
    }
  }

  /**
   * Extract and process vendor quotes from emails
   */
  async processVendorQuotes(projectId: string): Promise<any[]> {
    const communications = await prisma.communication.findMany({
      where: {
        projectId,
        type: 'EMAIL',
        direction: 'INBOUND',
        extractedData: { not: null }
      },
      include: {
        project: true
      }
    })

    const quotes = []

    for (const comm of communications) {
      const extractedData = comm.extractedData as any
      
      if (extractedData?.quote || extractedData?.pricing) {
        quotes.push({
          vendorId: comm.vendorId,
          communicationId: comm.id,
          quote: extractedData.quote || extractedData.pricing,
          receivedAt: comm.createdAt,
          confidence: extractedData.confidence || 0.8
        })
      }
    }

    return quotes
  }

  /**
   * Set up email labels for project organization
   */
  async setupProjectLabels(projectId: string, projectName: string): Promise<string[]> {
    try {
      const labelNames = [
        `Project: ${projectName}`,
        `Project: ${projectName}/RFPs`,
        `Project: ${projectName}/Quotes`,
        `Project: ${projectName}/Contracts`,
        `Project: ${projectName}/Issues`
      ]

      const createdLabels = []

      for (const labelName of labelNames) {
        try {
          const label = await this.gmail.users.labels.create({
            userId: 'me',
            requestBody: {
              name: labelName,
              labelListVisibility: 'labelShow',
              messageListVisibility: 'show'
            }
          })
          createdLabels.push(label.data.id)
        } catch (error) {
          // Label might already exist
          console.warn(`Label "${labelName}" might already exist:`, error.message)
        }
      }

      return createdLabels
    } catch (error) {
      console.error('Failed to setup project labels:', error)
      return []
    }
  }

  // Private helper methods

  private async getTemplate(templateId: string): Promise<EmailTemplate> {
    // In production, this would fetch from database
    const templates: Record<string, EmailTemplate> = {
      'rfp-standard': {
        id: 'rfp-standard',
        name: 'Standard RFP',
        subject: 'RFP: {{projectName}} - {{trade}} Services',
        body: this.getRFPTemplate(),
        variables: ['projectName', 'trade', 'description', 'timeline', 'contactInfo'],
        category: 'RFP'
      }
    }

    return templates[templateId]
  }

  private applyTemplate(template: EmailTemplate, variables: Record<string, any>): string {
    let body = template.body

    for (const [key, value] of Object.entries(variables)) {
      const regex = new RegExp(`{{${key}}}`, 'g')
      body = body.replace(regex, String(value))
    }

    return body
  }

  private generateRFPEmail(rfpData: RFPEmailData, vendor: any): string {
    return `
      <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
          <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
            <h2 style="color: #1e40af;">Request for Proposal: ${rfpData.projectName}</h2>
            
            <p>Dear ${vendor.name},</p>
            
            <p>We are seeking qualified ${rfpData.trade} contractors for our upcoming project in Liberty Hill, Texas. Based on our research, your company appears to be a strong candidate for this work.</p>
            
            <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 20px 0;">
              <h3 style="margin-top: 0; color: #1e40af;">Project Details</h3>
              <p><strong>Project:</strong> ${rfpData.projectName}</p>
              <p><strong>Trade:</strong> ${rfpData.trade}</p>
              <p><strong>Description:</strong> ${rfpData.description}</p>
              <p><strong>Location:</strong> Liberty Hill, Texas</p>
            </div>
            
            <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 20px 0;">
              <h3 style="margin-top: 0; color: #1e40af;">Timeline</h3>
              <p><strong>Project Start:</strong> ${rfpData.timeline.startDate.toLocaleDateString()}</p>
              <p><strong>Project End:</strong> ${rfpData.timeline.endDate.toLocaleDateString()}</p>
              <p><strong>Proposal Deadline:</strong> ${rfpData.timeline.responseDeadline.toLocaleDateString()}</p>
            </div>
            
            ${rfpData.requirements.length > 0 ? `
            <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 20px 0;">
              <h3 style="margin-top: 0; color: #1e40af;">Requirements</h3>
              <ul>
                ${rfpData.requirements.map(req => `<li>${req}</li>`).join('')}
              </ul>
            </div>
            ` : ''}
            
            ${rfpData.budget ? `
            <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 20px 0;">
              <h3 style="margin-top: 0; color: #1e40af;">Budget Information</h3>
              <p>Budget Range: $${rfpData.budget.min?.toLocaleString()} - $${rfpData.budget.max?.toLocaleString()} ${rfpData.budget.currency}</p>
            </div>
            ` : ''}
            
            <div style="background: #e3f2fd; padding: 15px; border-radius: 5px; margin: 20px 0; border-left: 4px solid #1e40af;">
              <h3 style="margin-top: 0; color: #1e40af;">What We Need From You</h3>
              <ul>
                <li>Detailed proposal with scope of work</li>
                <li>Timeline for completion</li>
                <li>Total cost breakdown (labor, materials, equipment)</li>
                <li>Proof of Texas contractor license and insurance</li>
                <li>References from recent similar projects</li>
                <li>Availability and start date</li>
              </ul>
            </div>
            
            <p>Please respond with your proposal by <strong>${rfpData.timeline.responseDeadline.toLocaleDateString()}</strong>. We will review all submissions and contact shortlisted vendors for follow-up discussions.</p>
            
            <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e0e0e0;">
              <p><strong>Contact Information:</strong></p>
              <p>${rfpData.contactInfo.name}<br>
              ${rfpData.contactInfo.company}<br>
              Email: ${rfpData.contactInfo.email}<br>
              ${rfpData.contactInfo.phone ? `Phone: ${rfpData.contactInfo.phone}` : ''}</p>
            </div>
            
            <p>Thank you for your time and consideration. We look forward to your proposal.</p>
            
            <p>Best regards,<br>
            ${rfpData.contactInfo.name}<br>
            ${rfpData.contactInfo.company}</p>
          </div>
        </body>
      </html>
    `
  }

  private getRFPTemplate(): string {
    return `
      <html>
        <body style="font-family: Arial, sans-serif;">
          <h2>Request for Proposal: {{projectName}}</h2>
          <p>Dear Contractor,</p>
          <p>{{description}}</p>
          <p>Timeline: {{timeline}}</p>
          <p>Contact: {{contactInfo}}</p>
        </body>
      </html>
    `
  }

  private parseGmailMessage(messageData: any): GmailMessage {
    const headers = messageData.payload.headers
    const getHeader = (name: string) => headers.find((h: any) => h.name === name)?.value || ''

    return {
      id: messageData.id,
      threadId: messageData.threadId,
      labelIds: messageData.labelIds || [],
      snippet: messageData.snippet,
      payload: messageData.payload,
      internalDate: messageData.internalDate,
      from: getHeader('From'),
      to: getHeader('To').split(',').map((email: string) => email.trim()),
      cc: getHeader('Cc').split(',').map((email: string) => email.trim()).filter(Boolean),
      subject: getHeader('Subject'),
      body: this.extractMessageBody(messageData.payload),
      attachments: this.extractAttachments(messageData.payload),
      isRead: !messageData.labelIds.includes('UNREAD'),
      date: new Date(parseInt(messageData.internalDate))
    }
  }

  private parseEmailThread(threadData: any): EmailThread {
    const messages = threadData.messages.map((msg: any) => this.parseGmailMessage(msg))
    const lastMessage = messages[messages.length - 1]

    return {
      id: threadData.id,
      messages,
      subject: lastMessage.subject,
      participants: [...new Set(messages.flatMap(m => [m.from, ...m.to]))],
      lastMessageDate: lastMessage.date,
      isRead: messages.every(m => m.isRead),
      labels: [...new Set(messages.flatMap(m => m.labelIds))]
    }
  }

  private extractMessageBody(payload: any): string {
    if (payload.body && payload.body.data) {
      return Buffer.from(payload.body.data, 'base64').toString()
    }

    if (payload.parts) {
      for (const part of payload.parts) {
        if (part.mimeType === 'text/html' || part.mimeType === 'text/plain') {
          if (part.body && part.body.data) {
            return Buffer.from(part.body.data, 'base64').toString()
          }
        }
      }
    }

    return ''
  }

  private extractAttachments(payload: any): EmailAttachment[] {
    const attachments: EmailAttachment[] = []

    if (payload.parts) {
      for (const part of payload.parts) {
        if (part.filename && part.body && part.body.attachmentId) {
          attachments.push({
            filename: part.filename,
            content: part.body.data ? Buffer.from(part.body.data, 'base64') : '',
            contentType: part.mimeType,
            size: part.body.size || 0
          })
        }
      }
    }

    return attachments
  }

  private async trackCommunication(data: any) {
    try {
      await prisma.communication.create({
        data: {
          projectId: data.projectId,
          type: 'EMAIL',
          subject: data.subject,
          content: data.content,
          direction: data.direction,
          fromEmail: data.fromEmail,
          toEmails: data.toEmails,
          ccEmails: data.ccEmails,
          gmailId: data.messageId,
          threadId: data.threadId,
          vendorId: data.vendorId,
          supplierId: data.vendorId,
          status: 'UNREAD',
          isAutoGenerated: data.isAutoGenerated || false,
          responseRequired: data.responseRequired || false,
          priority: 'MEDIUM'
        }
      })
    } catch (error) {
      console.error('Failed to track communication:', error)
    }
  }

  private async trackIncomingCommunication(message: GmailMessage) {
    // Extract project ID from subject or content
    const projectId = this.extractProjectIdFromEmail(message)
    const vendorId = await this.findVendorByEmail(message.from)

    if (projectId) {
      await this.trackCommunication({
        projectId,
        vendorId,
        messageId: message.id,
        threadId: message.threadId,
        direction: 'INBOUND',
        fromEmail: message.from,
        toEmails: message.to,
        ccEmails: message.cc,
        subject: message.subject,
        content: message.body,
        responseRequired: this.detectResponseRequired(message.body)
      })
    }
  }

  private extractProjectIdFromEmail(message: GmailMessage): string | null {
    // Look for project ID in subject line or email body
    const text = `${message.subject} ${message.body}`
    const projectMatch = text.match(/project[:\s]+([a-zA-Z0-9-_]+)/i)
    return projectMatch ? projectMatch[1] : null
  }

  private async findVendorByEmail(email: string): Promise<string | null> {
    const vendor = await prisma.supplier.findFirst({
      where: { email: email }
    })
    return vendor?.id || null
  }

  private detectResponseRequired(body: string): boolean {
    const responseKeywords = ['response', 'reply', 'answer', 'question', 'quote', 'proposal', 'rfp']
    const lowerBody = body.toLowerCase()
    return responseKeywords.some(keyword => lowerBody.includes(keyword))
  }
}

// Export singleton instance
export const gmailService = new GmailIntegrationService()