import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { gmailService } from '@/lib/gmail-integration-service'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const projectId = searchParams.get('projectId')
    const vendorId = searchParams.get('vendorId')
    const limit = parseInt(searchParams.get('limit') || '50')
    const includeGmail = searchParams.get('includeGmail') === 'true'
    
    // Build database query
    const where: any = {}
    
    if (projectId) {
      where.projectId = projectId
    }
    
    if (vendorId) {
      where.vendorId = vendorId
    }
    
    // Get communications from database
    const dbCommunications = await prisma.communication.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      take: limit,
      include: {
        project: {
          select: {
            id: true,
            name: true
          }
        }
      }
    })
    
    let gmailMessages = []
    
    // Optionally fetch from Gmail
    if (includeGmail) {
      try {
        const query = buildGmailQuery(projectId, vendorId)
        gmailMessages = await gmailService.fetchIncomingEmails(query, 20)
      } catch (error) {
        console.warn('Failed to fetch Gmail messages:', error.message)
      }
    }
    
    // Combine and format results
    const communications = dbCommunications.map(comm => ({
      id: comm.id,
      type: comm.type,
      direction: comm.direction,
      subject: comm.subject,
      content: comm.content,
      fromEmail: comm.fromEmail,
      toEmails: comm.toEmails,
      ccEmails: comm.ccEmails,
      status: comm.status,
      priority: comm.priority,
      responseRequired: comm.responseRequired,
      isAutoGenerated: comm.isAutoGenerated,
      createdAt: comm.createdAt,
      updatedAt: comm.updatedAt,
      project: comm.project,
      vendorId: comm.vendorId,
      supplierId: comm.supplierId,
      gmailId: comm.gmailId,
      threadId: comm.threadId,
      source: 'database'
    }))
    
    // Add Gmail messages that aren't already tracked
    const trackedGmailIds = new Set(dbCommunications.map(c => c.gmailId).filter(Boolean))
    
    const newGmailMessages = gmailMessages
      .filter(msg => !trackedGmailIds.has(msg.id))
      .map(msg => ({
        id: `gmail-${msg.id}`,
        type: 'EMAIL',
        direction: 'INBOUND',
        subject: msg.subject,
        content: msg.body,
        fromEmail: msg.from,
        toEmails: msg.to,
        ccEmails: msg.cc || [],
        status: msg.isRead ? 'READ' : 'UNREAD',
        priority: 'MEDIUM',
        responseRequired: false,
        isAutoGenerated: false,
        createdAt: msg.date,
        updatedAt: msg.date,
        project: null,
        vendorId: null,
        supplierId: null,
        gmailId: msg.id,
        threadId: msg.threadId,
        source: 'gmail'
      }))
    
    const allCommunications = [...communications, ...newGmailMessages]
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
      .slice(0, limit)

    return NextResponse.json({
      communications: allCommunications,
      total: allCommunications.length,
      fromDatabase: communications.length,
      fromGmail: newGmailMessages.length
    })
    
  } catch (error) {
    console.error('Failed to fetch communications:', error)
    return NextResponse.json(
      { error: 'Failed to fetch communications' },
      { status: 500 }
    )
  }
}

function buildGmailQuery(projectId?: string, vendorId?: string): string {
  const queryParts = ['is:unread']
  
  if (projectId) {
    queryParts.push(`subject:${projectId}`)
  }
  
  // Add vendor-specific query if needed
  // This would require looking up vendor email first
  
  return queryParts.join(' ')
}